package template

import (
	"context"
	"fmt"
	. "github.com/dave/jennifer/jen"
	mstrings "github.com/devimteam/microgen/generator/strings"
	"github.com/terraskye/vertical-slice-generator/eventmodel"
	"github.com/terraskye/vertical-slice-generator/generator/write_strategy"
	"os"
	"path/filepath"
	"strings"
)

type aggregateTemplate struct {
	info                   *GenerationInfo
	aggregateName          string
	alreadyRenderedMethods []string
	isStructExist          bool
	isConstructorExist     bool
}

func NewAggregateTemplate(info *GenerationInfo, aggregateName string) Template {
	return &aggregateTemplate{
		info:          info,
		aggregateName: aggregateName,
	}
}

// Renders stub code for service, its methods and constructor, that implements service interface.
//
//	// Generated by "microgen" tool.
//	// Structure stringService implements StringService interface.
//	type stringService struct {
//	}
//
//	func NewStringService() StringService {
//		panic("constructor not provided")
//	}
//
//	func (s *stringService) Count(ctx context.Context, text string, symbol string) (count int, positions []int) {
//		panic("method not provided")
//	}
func (t *aggregateTemplate) Render(ctx context.Context) write_strategy.Renderer {

	commandPackage, err := ResolvePackagePath(t.info.OutputFilePath + "/domain/commands")
	if err != nil {
		panic(err)
	}

	eventsPackage, err := ResolvePackagePath(t.info.OutputFilePath + "/events")
	if err != nil {
		panic(err)
	}

	f := &Statement{}

	if !t.isStructExist {
		f.Comment(`Generated Terraskye.`).Line().
			Type().Id(eventmodel.AggregateTitle(t.aggregateName)).Struct(
			Op("*").Qual(PackageEventSourcing, "AggregateBase"),
		).Line()
	} else {

	}

	for _, command := range t.info.Slice.Commands {
		if !mstrings.IsInStringSlice(eventmodel.ProcessTitle(command.Title), t.alreadyRenderedMethods) {
			f.Line().Add(
				Func().Params(
					Id(strings.ToLower(string(t.aggregateName[0]))).Op("*").Id(eventmodel.AggregateTitle(t.aggregateName))).Id(eventmodel.ProcessTitle(command.Title)).Params(
					Id("ctx").Qual("context", "Context"),
					// function params
					Id("cmd").Op("*").Qual(commandPackage, eventmodel.ProcessTitle(command.Title)),
				).Params(
					// function return params
					Error(),
				)).BlockFunc(func(group *Group) {

				group.Comment(t.info.Slice.Instructions())
				for _, s := range command.ProducesEvents() {
					event := t.info.Model.FindEventByID(s)
					group.Id(strings.ToLower(string(t.aggregateName[0]))).Dot("AppendEvent").
						Call(Op("&").Qual(eventsPackage, eventmodel.ProcessTitle(event.Title)).Block(DictFunc(func(dict Dict) {
							for _, field := range event.Fields {
								property := Id(eventmodel.ProcessTitle(field.Name))
								//if field.Cardinality != "Single" {
								//	property = property.Index()
								//}

								//dict[property] = Id("cmd").Dot(generator.ToCamelCase(field.Name))
								if len(event.Fields) > 1 {
									dict[property] = Id("cmd").Dot(eventmodel.ProcessTitle(field.Name))
								} else {
									dict[property] = Id("cmd").Dot(eventmodel.ProcessTitle(field.Name)).Op(",")
								}
							}
						})))
				}
				group.Return(Nil())
			})
		}
	}

	for _, event := range t.info.Slice.Events {
		if !mstrings.IsInStringSlice("On"+eventmodel.ProcessTitle(event.Title), t.alreadyRenderedMethods) {
			f.Line().Line().Add(
				Func().Params(
					Id(strings.ToLower(string(t.aggregateName[0]))).Op("*").Id(eventmodel.AggregateTitle(t.aggregateName))).Id("On" + eventmodel.ProcessTitle(event.Title)).Params(
					// function params
					Id("event").Op("*").Qual(eventsPackage, eventmodel.ProcessTitle(event.Title)),
				).Params()).Block()
		}
	}

	if !t.isStructExist {
		z := NewFile("domain")
		z.ImportAlias(PackageEventSourcing, "cqrs")
		z.ImportAlias(commandPackage, "")
		z.ImportAlias(eventsPackage, "")
		z.Add(f)
		return z
	}
	return f
}

func (t *aggregateTemplate) DefaultPath() string {
	return "domain/" + eventmodel.ScreenTitle(t.aggregateName) + ".go"
}

func (t *aggregateTemplate) Prepare(ctx context.Context) error {

	if err := statFile(t.info.OutputFilePath, t.DefaultPath()); os.IsNotExist(err) {
		fmt.Println("warning:", err)
		return nil
	}

	file, err := parsePackage(filepath.Join(t.info.OutputFilePath, t.DefaultPath()))
	if err != nil {
		return err
	}

	// Remove already provided service methods
	for i := range file.Methods {
		t.alreadyRenderedMethods = append(t.alreadyRenderedMethods, file.Methods[i].Name)
	}

	// Remove already provided service structure
	for i := range file.Structures {
		if file.Structures[i].Name == eventmodel.AggregateTitle(t.aggregateName) {
			t.isStructExist = true
			break
		}
	}

	return nil
}

func (t *aggregateTemplate) ChooseStrategy(ctx context.Context) (write_strategy.Strategy, error) {
	if err := statFile(t.info.OutputFilePath, t.DefaultPath()); os.IsNotExist(err) {
		return write_strategy.NewCreateFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil

	}

	return write_strategy.NewAppendToFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
}
