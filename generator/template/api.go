package template

import (
	"context"
	"fmt"
	"go/ast"
	"os"

	"github.com/terraskye/vertical-slice-generator/generator/write_strategy"
)

type apiTemplate struct {
	info *GenerationInfo
	// NEW
	runFunc           *ast.FuncDecl
	lastSliceBlockIdx int
	hasSliceBlocks    bool
}

func NewApiTemplate(info *GenerationInfo) Template {
	return &apiTemplate{
		info: info,
	}
}

// Renders stub code for service, its methods and constructor, that implements service interface.
//
//	// Generated by "microgen" tool.
//	// Structure stringService implements StringService interface.
//	type stringService struct {
//	}
//
//	func NewStringService() StringService {
//		panic("constructor not provided")
//	}
//
//	func (s *stringService) Count(ctx context.Context, text string, symbol string) (count int, positions []int) {
//		panic("method not provided")
//	}
func (t *apiTemplate) Render(ctx context.Context) write_strategy.Renderer {

	//commandPackage, err := ResolvePackagePath(t.info.OutputFilePath + "/domain/commands")
	//if err != nil {
	//	panic(err)
	//}
	//
	//eventsPackage, err := ResolvePackagePath(t.info.OutputFilePath + "/events")
	//if err != nil {
	//	panic(err)
	//}
	//
	//f := &Statement{}
	//
	//if !t.isStructExist {
	//	f.Comment(`Generated Terraskye.`).Line().
	//		Type().Id(eventmodel.AggregateTitle(t.apiName)).Struct(
	//		Op("*").Qual(PackageEventSourcing, "AggregateBase"),
	//	).Line()
	//} else {
	//
	//}
	//
	//for _, command := range t.info.Slice.Commands {
	//	if !mstrings.IsInStringSlice(eventmodel.ProcessTitle(command.Title), t.alreadyRenderedMethods) {
	//		f.Line().Add(
	//			Func().Params(
	//				Id(strings.ToLower(string(t.apiName[0]))).Op("*").Id(eventmodel.AggregateTitle(t.apiName))).Id(eventmodel.ProcessTitle(command.Title)).Params(
	//				Id("ctx").Qual("context", "Context"),
	//				// function params
	//				Id("cmd").Op("*").Qual(commandPackage, eventmodel.ProcessTitle(command.Title)),
	//			).Params(
	//				// function return params
	//				Error(),
	//			)).BlockFunc(func(group *Group) {
	//
	//			group.Comment(t.info.Slice.Instructions())
	//			for _, s := range command.ProducesEvents() {
	//				event := t.info.Model.FindEventByID(s)
	//				group.Id(strings.ToLower(string(t.apiName[0]))).Dot("AppendEvent").
	//					Call(Op("&").Qual(eventsPackage, eventmodel.ProcessTitle(event.Title)).Block(DictFunc(func(dict Dict) {
	//						for _, field := range event.Fields {
	//							property := Id(eventmodel.ProcessTitle(field.Name))
	//							//if field.Cardinality != "Single" {
	//							//	property = property.Index()
	//							//}
	//
	//							//dict[property] = Id("cmd").Dot(generator.ToCamelCase(field.Name))
	//							if len(event.Fields) > 1 {
	//								dict[property] = Id("cmd").Dot(eventmodel.ProcessTitle(field.Name))
	//							} else {
	//								dict[property] = Id("cmd").Dot(eventmodel.ProcessTitle(field.Name)).Op(",")
	//							}
	//						}
	//					})))
	//			}
	//			group.Return(Nil())
	//		})
	//	}
	//}
	//
	//for _, event := range t.info.Slice.Events {
	//	if !mstrings.IsInStringSlice("On"+eventmodel.ProcessTitle(event.Title), t.alreadyRenderedMethods) {
	//		f.Line().Line().Add(
	//			Func().Params(
	//				Id(strings.ToLower(string(t.apiName[0]))).Op("*").Id(eventmodel.AggregateTitle(t.apiName))).Id("On" + eventmodel.ProcessTitle(event.Title)).Params(
	//				// function params
	//				Id("event").Op("*").Qual(eventsPackage, eventmodel.ProcessTitle(event.Title)),
	//			).Params()).Block()
	//	}
	//}
	//
	//if !t.isStructExist {
	//	z := NewFile("domain")
	//	z.ImportAlias(PackageEventSourcing, "cqrs")
	//	z.ImportAlias(commandPackage, "")
	//	z.ImportAlias(eventsPackage, "")
	//	z.Add(f)
	//	return z
	//}
	//return f
	return nil
}

func (t *apiTemplate) DefaultPath() string {
	return "../api-2.go"
}

func (t *apiTemplate) Prepare(ctx context.Context) error {

	//filePath := filepath.Join(t.info.OutputFilePath, t.DefaultPath())
	// 1️⃣ Check if the file exists
	if err := statFile(t.info.OutputFilePath, t.DefaultPath()); os.IsNotExist(err) {
		fmt.Println("warning:", err)
		return nil
	}

	// 2️⃣ Parse the Go file into an AST
	//fset := token.NewFileSet()
	//file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	//if err != nil {
	//	return err
	//}

	// 5️⃣ Locate the Run method and analyze slice registration blocks
	t.runFunc = nil
	t.lastSliceBlockIdx = -1
	t.hasSliceBlocks = false

	//for _, fn := range file.Functions {
	//	if fn.Name != "Run" {
	//		continue
	//	}
	//
	//	t.runFunc = fn
	//	for i, stmt := range fn.Body.List {
	//		if t.isSliceRegistrationBlock(stmt) {
	//			t.lastSliceBlockIdx = i
	//			t.hasSliceBlocks = true
	//		}
	//	}
	//}

	return nil
}

func (t *apiTemplate) ChooseStrategy(ctx context.Context) (write_strategy.Strategy, error) {
	if err := statFile(t.info.OutputFilePath, t.DefaultPath()); os.IsNotExist(err) {
		return write_strategy.NewCreateFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil

	}

	return write_strategy.NewAppendToFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
}

func (t *apiTemplate) isSliceRegistrationBlock(stmt ast.Stmt) bool {
	block, ok := stmt.(*ast.BlockStmt)
	if !ok || len(block.List) < 2 {
		return false
	}

	expr, ok := block.List[0].(*ast.ExprStmt)
	if !ok {
		return false
	}

	call, ok := expr.X.(*ast.CallExpr)
	if !ok {
		return false
	}

	sel, ok := call.Fun.(*ast.SelectorExpr)
	return ok && sel.Sel.Name == "Register"
}
